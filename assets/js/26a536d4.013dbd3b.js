"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[635],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return _}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),m=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=m(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=m(n),_=o,d=u["".concat(l,".").concat(_)]||u[_]||p[_]||a;return n?r.createElement(d,i(i({ref:t},c),{},{components:n})):r.createElement(d,i({ref:t},c))}));function _(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var m=2;m<a;m++)i[m]=n[m];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8250:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return i},default:function(){return p},frontMatter:function(){return a},metadata:function(){return s},toc:function(){return m}});var r=n(3117),o=(n(7294),n(3905));const a={sidebar_position:5},i="ZIO Example",s={unversionedId:"zio-example",id:"zio-example",title:"ZIO Example",description:"ZIO exposes a lot of information about its own and application internals out-of-the-box - like ZIO Executor metrics and JVM metrics. In addition integrated ZIO Metrics DSL allows us to create custom metrics measuring effects of our choice.",source:"@site/../mesmer-docs/target/mdoc/zio-example.md",sourceDirName:".",slug:"/zio-example",permalink:"/docs/zio-example",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Supported metrics",permalink:"/docs/supported-metrics"}},l={},m=[{value:"Basic application",id:"basic-application",level:2},{value:"Enable ZIO Runtime and JVM metrics",id:"enable-zio-runtime-and-jvm-metrics",level:2},{value:"Add ZIO Metrics",id:"add-zio-metrics",level:2},{value:"Running the application with Java agent",id:"running-the-application-with-java-agent",level:2},{value:"Running the OpenTelemetry Collector",id:"running-the-opentelemetry-collector",level:2},{value:"Run the application",id:"run-the-application",level:2},{value:"Check the metrics",id:"check-the-metrics",level:2},{value:"mesmer_zio_executor",id:"mesmer_zio_executor",level:3},{value:"mesmer_zio_forwarded",id:"mesmer_zio_forwarded",level:3},{value:"http_server",id:"http_server",level:3},{value:"process_runtime",id:"process_runtime",level:3},{value:"Next steps",id:"next-steps",level:2}],c={toc:m};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"zio-example"},"ZIO Example"),(0,o.kt)("p",null,"ZIO exposes a lot of information about its own and application internals out-of-the-box - like ZIO Executor metrics and JVM metrics. In addition integrated ZIO Metrics DSL allows us to create custom metrics measuring effects of our choice."),(0,o.kt)("p",null,"When combined with OpenTelemetry Java Agent we're provided with even more extensive data about different parts our application."),(0,o.kt)("p",null,"In this example we will:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"create a simple web application"),(0,o.kt)("li",{parentName:"ul"},"enable all the available ZIO internal metrics"),(0,o.kt)("li",{parentName:"ul"},"add additional custom ZIO Metrics"),(0,o.kt)("li",{parentName:"ul"},"run the application with OpenTelemetry Java Agent and Mesmer extension")),(0,o.kt)("p",null,"The end result will be multiple metrics automatically exported to the metrics backend of our choice."),(0,o.kt)("h2",{id:"basic-application"},"Basic application"),(0,o.kt)("p",null,"We start with a simple ZIO HTTP application serving a ",(0,o.kt)("inlineCode",{parentName:"p"},"/healthcheck")," endpoint that answers with a ",(0,o.kt)("inlineCode",{parentName:"p"},"204 No Content")," response."),(0,o.kt)("p",null,"First we need add our dependencies and create the application:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'libraryDependencies ++= Seq(\n  "dev.zio" %% "zio"      % zioVersion,\n  "dev.zio" %% "zio-http" % zioHttpVersion\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport zio.http.model.{ Method, Status }\n\nobject AppZioHttp extends ZIOAppDefault {\n\n  val routes = Http.collectZIO[Request] {\n    case Method.GET -> !! / "healthcheck" =>\n      ZIO.succeed(Response.status(Status.NoContent))\n  }\n\n  override val run = \n    Server.serve(routes).provide(Server.default)\n\n}\n')),(0,o.kt)("h2",{id:"enable-zio-runtime-and-jvm-metrics"},"Enable ZIO Runtime and JVM metrics"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport zio.http.model.{ Method, Status }\nimport zio.metrics.jvm.DefaultJvmMetrics\n\nobject AppZioHttp extends ZIOAppDefault {\n\n  val routes = Http.collectZIO[Request] {\n    case Method.GET -> !! / "healthcheck" =>\n      ZIO.succeed(Response.status(Status.NoContent))\n  }\n\n  override val run = \n    Server.serve(routes).provide(\n      Server.default,\n      Runtime.enableRuntimeMetrics,\n      DefaultJvmMetrics.live.unit\n    )\n\n}\n')),(0,o.kt)("h2",{id:"add-zio-metrics"},"Add ZIO Metrics"),(0,o.kt)("p",null,"Now let's add a simple metric that will count the requests:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.http._\nimport zio.http.model.{ Method, Status }\nimport zio.metrics._\nimport zio.metrics.jvm.DefaultJvmMetrics\n\nobject AppZioHttp extends ZIOAppDefault {\n\n  val requestCount = \n    Metric.counterInt("request_count").fromConst(1)\n      .tagged(\n        MetricLabel("method", "GET"),\n        MetricLabel("handler", "/healthcheck")\n      )\n\n  val routes = Http.collectZIO[Request] {\n    case Method.GET -> !! / "healthcheck" =>\n      ZIO.succeed(Response.status(Status.NoContent)) @@ requestCount\n  }\n\n  override val run = \n    Server.serve(routes).provide(\n      Server.default,\n      Runtime.enableRuntimeMetrics,\n      DefaultJvmMetrics.live.unit\n    )\n\n}\n')),(0,o.kt)("p",null,"From the application code perspective this is all we need to export metrics to an OpenTelemetry collector. The rest is about OpenTelemetry and Mesmer configuration."),(0,o.kt)("h2",{id:"running-the-application-with-java-agent"},"Running the application with Java agent"),(0,o.kt)("p",null,"Right now our application doesn't export any metrics as it doesn't know anything about OpenTelemetry and has no ZIO Metrics exporter declared. And we want it to stay that way."),(0,o.kt)("p",null,"By running the application with OpenTelemetry Agent and Mesmer extension we achieve 2 things:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"OpenTelemetry Agent will auto-instrument all the supported libraries that it detects (in our case Netty is the significant one because of ZIO HTTP)"),(0,o.kt)("li",{parentName:"ul"},"Mesmer extension will auto-instrument all the metrics exposed by ZIO and translate it to OpenTelemetry instruments.")),(0,o.kt)("p",null,"To run the application with Java agents from ",(0,o.kt)("inlineCode",{parentName:"p"},"sbt")," add these lines to the ",(0,o.kt)("inlineCode",{parentName:"p"},"build.sbt")," file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'run / fork := true\nrun / javaOptions ++= Seq(\n  "-javaagent:path/to/opentelemetry-javaagent.jar",\n  "-Dotel.javaagent.extensions=path/to/mesmer-otel-extension.jar",\n)\n')),(0,o.kt)("p",null,"You can find more information about downloading these files at the ",(0,o.kt)("a",{parentName:"p",href:"/docs/getting-started"},"Getting Started")," page."),(0,o.kt)("h2",{id:"running-the-opentelemetry-collector"},"Running the OpenTelemetry Collector"),(0,o.kt)("p",null,"By default Mesmer and OpenTelemetry agent will export metrics using OTLP over gRPC to an OTel Collector running at localhost."),(0,o.kt)("p",null,"To run OTel Collector using docker-compose add this to your docker-compose.yaml:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"version: '3.3'\n\nservices:\n  otel-collector:\n    container_name: my_otel_collector\n    image: otel/opentelemetry-collector-contrib-dev:latest\n    command: [--config=/etc/otel-collector-config.yaml, '']\n    volumes:\n    - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml\n    ports:\n    - 1888:1888     # pprof extension\n    - 8888:8888     # Prometheus metrics exposed by the collector\n    - 8889:8889     # Prometheus exporter metrics\n    - 13133:13133   # health_check extension\n    - 55681:55679   # zpages extension\n    - 4317:4317     # otlp receiver\n")),(0,o.kt)("p",null,"Docker-compose will expect ",(0,o.kt)("inlineCode",{parentName:"p"},"otel-collector-config.yaml")," file to exist. "),(0,o.kt)("p",null,"This is an example configuration for a Collector exposing metrics in Prometheus format:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"receivers:\n  otlp:\n    protocols:\n      grpc:\n\nexporters:\n  prometheus:\n    endpoint: 0.0.0.0:8889\n    namespace: testzioapp\n  logging:\n    loglevel: info\n\nprocessors:\n  batch:\n\nextensions:\n  health_check:\n  pprof:\n    endpoint: :1888\n  zpages:\n    endpoint: :55679\n\nservice:\n  extensions: [pprof, zpages, health_check]\n  pipelines:\n    metrics:\n      receivers: [otlp]\n      processors: [batch]\n      exporters: [prometheus]\n")),(0,o.kt)("p",null,"More about OTel Collector configuration can found ",(0,o.kt)("a",{parentName:"p",href:"https://opentelemetry.io/docs/collector/configuration/"},"here"),"."),(0,o.kt)("h2",{id:"run-the-application"},"Run the application"),(0,o.kt)("p",null,"Now with all of the above set up we can run the application from ",(0,o.kt)("inlineCode",{parentName:"p"},"sbt")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"sbt run\n")),(0,o.kt)("p",null,"and make a couple of calls to the ",(0,o.kt)("inlineCode",{parentName:"p"},"/healthcheck")," endpoint"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"curl http://localhost:8080/healthcheck\n")),(0,o.kt)("h2",{id:"check-the-metrics"},"Check the metrics"),(0,o.kt)("p",null,"To get the metrics from OTel Collector we can use the same endpoint as Prometheus would use to acquire them:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"curl http://localhost:8889/metrics\n")),(0,o.kt)("p",null,"In the response body we will receive a list of metrics in the Prometheus format with different name prefixes. Following is the list of all of the metrics broken down by name prefix: "),(0,o.kt)("h3",{id:"mesmer_zio_executor"},"mesmer_zio_executor"),(0,o.kt)("p",null,"ZIO Executor metrics exposed by ZIO"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"mesmer_zio_executor_dequeued_count - The number of tasks that have been dequeued, over all time.\nmesmer_zio_executor_size           - The number of tasks remaining to be executed.\nmesmer_zio_executor_worker_count   - The number of current live worker threads.\nmesmer_zio_executor_enqueued_count - The number of tasks that have been enqueued, over all time.\nmesmer_zio_executor_concurrency    - The concurrency level of the executor.\nmesmer_zio_executor_capacity       - The capacity of the executor.\n")),(0,o.kt)("h3",{id:"mesmer_zio_forwarded"},"mesmer_zio_forwarded"),(0,o.kt)("p",null,"This name prefix includes runtime and JVM metrics (enabled by additional ",(0,o.kt)("inlineCode",{parentName:"p"},"ZLayers"),") as well as the custom merics defined using ZIO Metrics DSL."),(0,o.kt)("p",null,"The custom ",(0,o.kt)("inlineCode",{parentName:"p"},"request_count")," metric (in full Prometheus format):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'mesmer_zio_forwarded_request_count_total{otel_scope_name="mesmer",handler="/healthcheck",method="GET"} 10.0 1680557471485\n')),(0,o.kt)("p",null,"ZIO Runtime and JVM metrics:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"mesmer_zio_forwarded_zio_fiber_successes_total \n\nmesmer_zio_forwarded_process_max_fds \nmesmer_zio_forwarded_process_resident_memory_bytes \nmesmer_zio_forwarded_process_open_fds \nmesmer_zio_forwarded_process_cpu_seconds_total \nmesmer_zio_forwarded_process_virtual_memory_bytes \nmesmer_zio_forwarded_process_start_time_seconds \n\nmesmer_zio_forwarded_jvm_buffer_pool_capacity_bytes \nmesmer_zio_forwarded_jvm_threads_started_total \nmesmer_zio_forwarded_jvm_memory_pool_bytes_used \nmesmer_zio_forwarded_jvm_threads_daemon \nmesmer_zio_forwarded_jvm_gc_collection_seconds_count \nmesmer_zio_forwarded_jvm_memory_pool_bytes_committed \nmesmer_zio_forwarded_jvm_threads_peak \nmesmer_zio_forwarded_jvm_memory_pool_collection_committed_bytes \nmesmer_zio_forwarded_jvm_memory_bytes_max \nmesmer_zio_forwarded_jvm_memory_pool_bytes_init \nmesmer_zio_forwarded_jvm_buffer_pool_used_buffers \nmesmer_zio_forwarded_jvm_memory_pool_bytes_max \nmesmer_zio_forwarded_jvm_memory_bytes_used \nmesmer_zio_forwarded_jvm_threads_current \nmesmer_zio_forwarded_jvm_classes_loaded \nmesmer_zio_forwarded_jvm_classes_loaded_total \nmesmer_zio_forwarded_jvm_memory_pool_collection_used_bytes \nmesmer_zio_forwarded_jvm_gc_collection_seconds_sum \nmesmer_zio_forwarded_jvm_memory_pool_allocated_bytes_total_total \nmesmer_zio_forwarded_jvm_classes_unloaded_total \nmesmer_zio_forwarded_jvm_memory_pool_collection_max_bytes \nmesmer_zio_forwarded_jvm_memory_pool_collection_init_bytes \nmesmer_zio_forwarded_jvm_threads_deadlocked_monitor \nmesmer_zio_forwarded_jvm_threads_state \nmesmer_zio_forwarded_jvm_threads_deadlocked \nmesmer_zio_forwarded_jvm_memory_objects_pending_finalization \nmesmer_zio_forwarded_jvm_buffer_pool_used_bytes \nmesmer_zio_forwarded_jvm_memory_bytes_committed \nmesmer_zio_forwarded_jvm_info \nmesmer_zio_forwarded_jvm_memory_bytes_init \n")),(0,o.kt)("h3",{id:"http_server"},"http_server"),(0,o.kt)("p",null,"Metrics provided by OpenTelemetry Agent's auto-instrumentation for Netty:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"http_server_duration        - The duration of the inbound HTTP request\nhttp_server_request_size    - The size of HTTP request messages\nhttp_server_active_requests - The number of concurrent HTTP requests that are currently in-flight\n")),(0,o.kt)("h3",{id:"process_runtime"},"process_runtime"),(0,o.kt)("p",null,"JVM metrics provided by OpenTelemetry Agent"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"process_runtime_jvm_threads_count              - Number of executing threads\nprocess_runtime_jvm_classes_current_loaded     - Number of classes currently loaded\nprocess_runtime_jvm_memory_committed           - Measure of memory committed\nprocess_runtime_jvm_buffer_usage               - Memory that the Java virtual machine is using for this buffer pool\nprocess_runtime_jvm_memory_usage               - Measure of memory used\nprocess_runtime_jvm_system_cpu_load_1m         - Average CPU load of the whole system for the last minute\nprocess_runtime_jvm_classes_unloaded_total     - Number of classes unloaded since JVM start\nprocess_runtime_jvm_buffer_count               - The number of buffers in the pool\nprocess_runtime_jvm_gc_duration                - Duration of JVM garbage collection actions\nprocess_runtime_jvm_memory_init                - Measure of initial memory requested\nprocess_runtime_jvm_memory_usage_after_last_gc - Measure of memory used after the most recent garbage collection event on this pool\nprocess_runtime_jvm_system_cpu_utilization     - Recent cpu utilization for the whole system\nprocess_runtime_jvm_buffer_limit               - Total capacity of the buffers in this pool\nprocess_runtime_jvm_classes_loaded_total       - Number of classes loaded since JVM start\nprocess_runtime_jvm_memory_limit               - Measure of max obtainable memory\nprocess_runtime_jvm_cpu_utilization            - Recent cpu utilization for the process\n")),(0,o.kt)("h2",{id:"next-steps"},"Next steps"),(0,o.kt)("p",null,"TODO Connect Prometheus and Graphana"))}p.isMDXComponent=!0}}]);